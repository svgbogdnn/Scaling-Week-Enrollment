# A. Предсказание ошибок

**Тип задания:** [csv файл]  
**Формат решения:** полное решение  
**Ограничения:**  
- Время: 20 секунд  
- Память: 256 Мб  

## Описание

Нерадивый ML-инженер Тензорослав обучал линейную регрессию на некотором датасете.  
Он не был знаком с градиентными методами оптимизации, поэтому искал оптимум с помощью случайного поиска.  

Он сгенерировал несколько случайных векторов весов и посчитал среднеквадратичную ошибку (MSE) для каждого вектора.  
В какой-то момент Тензорослав случайно удалил выборку, на которой он считал MSE.

Нужно помочь Тензорославу закончить начатое и предсказать значение MSE для тех векторов весов, которые он ещё не успел обработать.

## Датасет

Даны три файла:

- `train_weights.csv` — содержит:
  - колонки `W0`–`W9` — 10-мерные векторы весов;
  - колонку `MSE` — соответствующие значения ошибки.
- `test_weights.csv` — содержит тестовые векторы весов, для которых нужно предсказать `MSE`.
- `example` — пример корректной посылки в контест.

## Что нужно сделать

Необходимо предсказать колонку `MSE` для векторов из файла `test_weights.csv` и загрузить файл `answers` в формате, аналогичном примеру.

## Метрика и оценка

Целевая метрика: корень из средней квадратичной логарифмической ошибки (RMSLE).

Баллы рассчитываются по формуле:

\[
\text{score} = 100 \cdot \max\left( \min\left( \frac{0{.}3 - \text{RMSLE}}{0{.}1}, 1 \right), 0 \right)
\]

Для получения максимального балла (100) необходимо достичь `RMSLE ≤ 0.2`.

## Формат вывода

Файл `answers` (без пробелов в названии) в формате JSON.  
Каждый элемент массива — объект с полями `W0`–`W9` и предсказанным `MSE`:

```json
[
    {
        "W0": 0.465,
        "W1": 0.582,
        "W2": 1.071,
        "W3": -1.889,
        "W4": -0.92,
        "W5": -1.084,
        "W6": -1.003,
        "W7": -0.766,
        "W8": -0.858,
        "W9": 0.665,
        "MSE": 40.593
    }
    ...
]
```


---

# B. Лаборатория биокибернетики

**Тип задания:** [csv файл]  
**Формат решения:** полное решение  
**Ограничения:**  
- Время: 20 секунд  
- Память: 200 Мб  

## Описание

Исследователи из лаборатории биокибернетики разработали алгоритм для классификации биологических объектов.

Младший научный сотрудник предложил простое определение:  
«Объект класса X — это организм с двумя конечностями и без перьевого покрова».

Старший коллега принёс в лабораторию ощипанную курицу и заметил:  
«По вашему определению, это тоже объект X!».

Пришлось уточнить критерий: «…и с плоскими когтями».

Для автоматизации классификации исследователи закодировали признаки организмов латинскими буквами от `A` до `I`.  
Что означает каждый признак — не раскрывается.

Команда собрала данные:

- Младший сотрудник подготовил обучающую выборку с метками.
- Старший сотрудник подготовил тестовую выборку, но забыл указать классы и ушёл на перерыв.

Задача: по обучающим данным предсказать метки классов для тестовой выборки.

## Датасет

Три файла: `train.csv`, `test.csv`, `example.csv`.

- `train.csv` — содержит признаки обучающей выборки и колонку разметки `target`:
  - `target = 1` — человек;
  - `target = 0` — нечеловек.
- `test.csv` — содержит признаки тестовой выборки.
- `example.csv` — пример корректной посылки.

Нужно предсказать колонку `target` для объектов из `test.csv`.

## Что нужно сделать

Необходимо загрузить в систему файл `answers.csv` в формате, аналогичном `example.csv`, с предсказаниями `target` для объектов из тестовой выборки.

## Метрика и оценка

Целевая метрика: ROC-AUC.

Баллы рассчитываются по формуле:

\[
\text{score} =
100 \cdot \max\left(
  \min\left(
    \frac{\text{AUC} - 0{.}8}{0{.}08},
    1
  \right),
  0
\right)
\]

где `AUC` — значение ROC-AUC ваших предсказаний.

Для максимального числа баллов необходимо набрать `AUC ≥ 0.88`.


---

# C. Доставка заказов

**Формат решения:** полное решение  
**Ограничения:**  
- Время: 2 секунды  
- Память: 512 Мб  

**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`  

## Описание

Яндекс тестирует автономного курьера-ровера и хочет понять, насколько быстро он сможет развозить заказы по городу.

Город задан прямоугольной решёткой `n × m`.  
Все адреса поделены на 26 типов и обозначены строчными латинскими буквами от `a` до `z`.

Диспетчер выдал роверу список доставок в виде строки `s`:  
`i`-й символ — это тип адреса, на который нужно выполнить `i`-ю доставку.  
Доставки нужно выполнять строго в порядке символов строки `s`.

Строки решётки пронумерованы от `1` до `n` сверху вниз, столбцы — от `1` до `m` слева направо.  
Клетка `(x, y)` — пересечение строки `x` и столбца `y`.

Изначально ровер находится в клетке `(s_x, s_y)`.

В клетке `(i, j)` расположен адрес типа `x_{i,j}`.  
Для каждого типа таких адресов может быть несколько — доставку можно выполнить в любой клетке с нужным типом.

Ровер может перемещаться только по сторонам (вверх, вниз, влево, вправо), каждый переход занимает 1 единицу времени.  
Передача заказа, если ровер уже находится в нужной клетке, считается мгновенной.

Нужно определить минимальное время, за которое ровер выполнит все доставки из списка `s`.

## Формат ввода

1. Первая строка: два целых числа `n` и `m` — размеры города  
   `1 ≤ n, m ≤ 300`.
2. Вторая строка: два целых числа `s_x` и `s_y` — начальные координаты ровера  
   `1 ≤ s_x ≤ n`, `1 ≤ s_y ≤ m`.
3. Далее идут `n` строк, каждая из которых состоит ровно из `m` строчных английских букв.  
   В `i`-й из этих строк `j`-й символ задаёт тип адреса `x_{i,j}` в клетке `(i, j)`.  
   Гарантируется, что каждый из 26 типов встречается хотя бы один раз.
4. Далее вводится строка `s` — последовательность доставок, состоящая из строчных английских букв.  
   `1 ≤ |s| ≤ 300`.

## Формат вывода

Выведите одно целое число — минимальное время, необходимое роверy для выполнения всех доставок из списка `s`.

## Пример 1

**Ввод:**
```text
2 26
1 1
abcdefghijklmnopqrstuvwxyz
abtxyzutalkhfdyutxzbzhhawj
nut
```

**Вывод:**
```text
17
```

Пояснение к примеру:  
Оптимальный маршрут — дойти за 12 шагов до ближайшей клетки с адресом типа `n`, затем спуститься на 1 клетку вниз и последовательно выполнить доставки к адресам типов `u` и `t`, стоящим подряд справа, что потребует ещё 4 шага.

## Пример 2

**Ввод:**
```text
7 7
4 4
abcdefg
xyzabch
wnopqdi
vmvwrej
ulutsfk
tkjihgl
srqponm
squirrel
```

(Ответ в этом примере в условии поясняется через последовательность клеток.)

Пояснение к примеру:  
Оптимальный маршрут задаётся последовательностью точек:

- `(4, 4)` — исходное положение, далее `s`;
- `(5, 5)` — `q`;
- `(3, 5)` — `u`;
- `(5, 3)` — `i`;
- `(6, 4)` — `r`;
- `(4, 5)` — `r` (повторно);
- `(4, 6)` — `e`;
- `(6, 7)` — `l`.


---

# D. Распределённая система

**Формат решения:** полное решение  
**Ограничения:**  
- Время: 1 секунда  
- Память: 64 Мб  

**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`  

## Описание

Рассматривается распределённая вычислительная система из `n` вычислительных узлов (серверов).  
Между узлами есть каналы связи, образующие дерево (сеть без циклов, между любой парой узлов — единственный путь).

Эта структура задаёт топологию обмена сообщениями — какие узлы могут взаимодействовать напрямую.

Есть множество из `n` географически распределённых дата-центров, каждый из которых может быть назначен под один вычислительный узел.  
Дата-центры расположены в точках общего положения на плоскости:

- никакие три не лежат на одной прямой;
- никакие две точки не совпадают.

Задача: сопоставить каждой вершине дерева (вычислительному узлу) уникальный дата-центр (точку на плоскости) так, чтобы при визуализации рёбер дерева прямыми линиями между соответствующими точками любые несмежные рёбра не пересекались.

## Формат ввода

- Первая строка: целое число `t` — количество тестов.  
  `1 ≤ t ≤ 1000`.

Далее для каждого теста:

1. Первая строка теста: целое число `n` — количество узлов (и одновременно точек).  
   Ограничение: `2 ≤ n ⋅ t ≤ 1000`.
2. Следующие `n − 1` строк описывают рёбра дерева.  
   Каждая строка: два целых числа `u` и `v` (`1 ≤ u, v ≤ n`) — номера вершин, соединённых ребром.  
   Гарантируется, что граф — дерево: нет циклов и ровно `n − 1` ребро.
3. Далее идут `n` строк — координаты точек.  
   Каждая строка: два действительных числа `x_i`, `y_i` — координаты `i`-й точки на плоскости, в которую можно сопоставить вершину.  
   Ограничение: `-10^4 < x_i, y_i < 10^4`.

## Формат вывода

Для каждого теста выведите одну строку, содержащую `n` целых чисел `p1, p2, …, pn` — перестановку чисел от `1` до `n`.

- `p_i` означает, что вершине `i` дерева сопоставляется `p_i`-я точка из входного списка.

Таким образом, каждой вершине дерева выбирается уникальная точка на плоскости так, чтобы соединение вершин прямыми отрезками между соответствующими точками не приводило к пересечениям несмежных рёбер.

## Примеры

### Пример 1

**Ввод:**
```text
1
2
1 2
292.365297 561.624168
28.742075 869.836531
```

**Вывод:**
```text
2 1
```

### Пример 2

**Ввод:**
```text
1
3
2 1
1 3
38.082299 -593.978441
-42.281845 -296.136429
217.814614 -47.946068
```

**Вывод:**
```text
3 2 1
```

## Визуализатор для дебага

Для отладки решений предлагается использовать визуализатор.

```python
import argparse
import matplotlib.pyplot as plt


def read_input_and_output(infile, outfile):
    # Чтение входа
    input_data = list(map(float, infile.read().split()))
    it = iter(input_data)
    t = int(next(it))
    if t != 1:
        raise ValueError("Визуализатор поддерживает только один тест.")
    n = int(next(it))
    edges = [(int(next(it)) - 1, int(next(it)) - 1) for _ in range(n - 1)]
    points = [(next(it), next(it)) for _ in range(n)]

    # Чтение вывода (перестановка)
    perm = list(map(int, outfile.read().split()))
    if len(perm) != n:
        raise ValueError("Размер перестановки не совпадает с числом вершин")

    assigned = [points[p - 1] for p in perm]
    return n, edges, assigned


def visualize(n, edges, assigned, show_ids=False):
    fig, ax = plt.subplots()
    xs, ys = zip(*assigned)
    ax.scatter(xs, ys)

    for i, (x, y) in enumerate(assigned):
        if show_ids:
            ax.text(x, y, str(i + 1), fontsize=8, ha="right", va="bottom")

    for u, v in edges:
        x1, y1 = assigned[u]
        x2, y2 = assigned[v]
        ax.plot([x1, x2], [y1, y2])

    ax.set_aspect("equal")
    ax.set_title("Дерево на плоскости")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()
    plt.show()


def main():
    parser = argparse.ArgumentParser(description="Визуализатор вложенного дерева")
    parser.add_argument(
        "--infile",
        type=argparse.FileType("r"),
        help="Входной файл",
        default="input.txt",
    )
    parser.add_argument(
        "--outfile",
        type=argparse.FileType("r"),
        help="Файл с перестановкой",
        default="output.txt",
    )
    parser.add_argument(
        "--show-ids", action="store_true", help="Показывать номера вершин", default=True
    )
    args, unknown = parser.parse_known_args()

    n, edges, assigned = read_input_and_output(args.infile, args.outfile)
    visualize(n, edges, assigned, args.show_ids)


if __name__ == "__main__":
    main()
```
